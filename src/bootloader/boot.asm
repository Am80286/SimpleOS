;    This file is part of SimpleOS.
;
;    SimpleOS is free software: you can redistribute it and/or modify it under the terms of the 
;    GNU General Public License as published by the Free Software Foundation, either version 3 
;    of the License, or (at your option) any later version.
;
;    SimpleOS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
;    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
;    See the GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along with SimpleOS. 
;    If not, see <https://www.gnu.org/licenses/>. 

[org 0x7c00]
[bits 16]

jmp short BOOT_START
nop

;These values get replaced by one generated by mkfs.fat during image creation process
BS_OEMName                  db "MSWIN4.1"
BPB_BytesPerSec             dw 512
BPB_SecPerClus              db 16
BPB_RsvdSecCnt              dw 16
BPB_FatNum                  db 2
BPB_RootEntCnt              dw 512
BPB_TotalSecCnt             dw 0
BPB_Media_Desc_Type         db 0xf8
BPB_SecPerFat               dw 256
BPB_SecPerTrack             dw 63
BPB_Heads                   dw 32
BPB_HiddenSectors           dd 0
BPB_LargeSecCnt             dd 1048576

%ifndef FAT32

EBR_BootDrvNumber           db 99
                            db 0
EBR_Signature               db 0x29
EBR_VolumeId                db 0xFF, 0xFF,0xFF, 0xFF
EBR_VolumeLbl               db "NO NAME    "
EBR_SysId                   db "FAT16  "

%else

BPB_FatSz32                 dd 0
BPB_ExtFlags                dw 0
BPB_FSver                   dw 0
BPB_RootClus                dd 0
BPB_FSinfo                  dw 0
BPB_BkBootSec               dw 0

BPB_Reserved       times 12 db 0
EBR_BootDrvNumber           db 0
                            db 0
EBR_Signature               db 0x29
EBR_VolumeId                db 0xFF, 0xFF,0xFF, 0xFF
EBR_VolumeLbl               db "NO NAME    "
EBR_SysId                   db "FAT32  "

%endif


[CPU 386]
[section .text]
    BOOT_START:
        xor ax, ax
        mov es, ax
        mov ds, ax
        mov ss, ax
        
        mov byte[EBR_BootDrvNumber], dl

        mov sp, 0x7c00
        mov bp, sp

    INIT_BOOT_DISK:
        push es

        mov ah, 0x08
        int 0x13
        jc CRIT_ERROR
        pop es

        inc dh
        mov [BPB_Heads], dh
        and cl, 0x3f
        xor ch, ch
        mov [BPB_SecPerTrack], cx

        mov ax, [BPB_SecPerFat]
        xor bh, bh
        mov bl, [BPB_FatNum]
        mul bx
        add ax, [BPB_RsvdSecCnt]
        push ax
        mov ax, 32
        mov bx, [BPB_RootEntCnt]
        mul bx
        add ax, [BPB_BytesPerSec]
        dec ax
        mov bx, [BPB_BytesPerSec]
        div bx
        pop bx
        add ax, bx
        mov [DATA_START_SEC], ax

%ifndef FAT32

    LOAD_ROOT_DIR:
        mov al, [BPB_FatNum]
        xor ah, ah
        mov bx, [BPB_SecPerFat]
        mul bx
        add ax, [BPB_RsvdSecCnt]

        push ax ;Root dir start sector
        
        mov ax, [BPB_RootEntCnt]
        shl ax, 5
        xor dx, dx
        div word[BPB_BytesPerSec]

        test dx, dx
        jz .done 
        inc ax

%else

    LOAD_ROOT_DIR:
        mov al, [BPB_FatNum]
        xor ah, ah
        mov bx, [BPB_SecPerFat]
        mul bx
        add ax, [BPB_RsvdSecCnt]

        push ax ;Root dir start sector
        
        mov ax, [BPB_RootEntCnt]
        shl ax, 5
        xor dx, dx
        div word[BPB_BytesPerSec]

        test dx, dx
        jz .done 
        inc ax

%endif

    .done:
        mov cx, ax ; AX - root dir sector count 
        pop ax
        mov bx, BUFFER_POINTER
        call READ_LBA

    LOAD_STAGE2:
        mov ax, word[BPB_RootEntCnt]
        mov si, BOOT_DIR
        mov di, BUFFER_POINTER
        call SEARCH_DIR

        xor dx, dx
        mov ax, word[BPB_BytesPerSec]
        mov bx, BUFFER_POINTER
        add bx, ax                  ; This offset is needed, because the FAT already occupies the first 512 bytes of the buffer space

        call LOAD_DIR_ENTRY

        mov ax, 0xffff
        mov si, STAGE2_FILE
        mov di, bx
        call SEARCH_DIR

        mov dx, STAGE2_SEG
        mov bx, STAGE2_OFF
        call LOAD_DIR_ENTRY

        mov dl, byte[EBR_BootDrvNumber]
        mov ax, STAGE2_SEG
        mov ds, ax

        jmp STAGE2_SEG:STAGE2_OFF

%ifndef FAT32
    SEARCH_DIR: ; DS:SI - pointer to name string, ES:DI - pointer to directory, AX - number of entries to check
        pusha
        xor bx, bx

    .loop:
        mov cx, 11
        push si
        push di
        repe cmpsb
        pop di
        pop si

        je .found
        inc bx

        add di, 32
        cmp bx, ax
        jb .loop

        jmp CRIT_ERROR
        
    .found: ;directory entry pointer is in DI register
        mov ax, [di + 26]
        mov [FILE_CLUSTER], ax

        popa
        ret

%else

    SEARCH_DIR: ; DS:SI - pointer to name string, ES:DI - pointer to directory, AX - number of entries to check
        pusha
        xor bx, bx

    .loop:
        mov cx, 11
        push si
        push di
        repe cmpsb
        pop di
        pop si

        je .found
        inc bx

        add di, 32
        cmp bx, ax
        jb .loop

        jmp CRIT_ERROR
        
    .found: ;directory entry pointer is in DI register
        mov ax, [di + 26]
        mov word[FILE_CLUSTER + 2], ax
        mov ax, [di + 20]
        mov word[FILE_CLUSTER], ax

        popa
        ret

%endif

%ifdef FAT32

    LOAD_DIR_ENTRY: ; FILE_CLUSTER - first cluster of a directory entry, DX:BX - load adress
        pusha
        push es
        mov es, dx

    .loop:
        xor ecx, ecx
        mov cl, byte[BPB_SecPerClus]
        mov eax, dword[FILE_CLUSTER]
        sub eax, 2
        mul ecx
        add ax, word[DATA_START_SEC]

        call READ_LBA

        mov ax, word[BPB_BytesPerSec]
        xor dh, dh
        mov dl, byte[BPB_SecPerClus]
        mul dx
        add bx, ax

    .read_fat:
        xor edx, edx
        mov eax, dword[FILE_CLUSTER]
        shl ax, 2
        mov cx, word[BPB_BytesPerSec]
        div ecx
        mov cx, word[BPB_RsvdSecCnt]
        add eax, ecx
        mov cx, 1

        call READ_LBA

        add dx, bx
        mov si, dx
        mov eax, dword[es:si]
        and eax, 0x0FFFFFFF

        cmp eax, 0x0FFFFFF8
        jae .done

        mov dword[FILE_CLUSTER], eax
        jmp .loop

    .done:
        pop es
        popa
        ret

%endif

%ifdef FAT16

    LOAD_DIR_ENTRY: ; FILE_CLUSTER - first cluster of a directory entry, DX:BX - load adress
        pusha
        push es
        mov es, dx

    .loop:
        xor ch, ch
        mov cl, byte[BPB_SecPerClus]
        mov ax, word[FILE_CLUSTER]
        sub ax, 2
        mul cx
        add ax, [DATA_START_SEC]

        call READ_LBA

        mov ax, word[BPB_BytesPerSec]
        xor dh, dh
        mov dl, byte[BPB_SecPerClus]
        mul dx
        add bx, ax

    .read_fat:
        push es
        push bx

        xor dx, dx
        mov ax, word[FILE_CLUSTER]
        shl ax, 1
        div word[BPB_BytesPerSec]
        add ax, word[BPB_RsvdSecCnt]
        mov cx, 1

        mov bx, BOOTLOADER_SEG
        mov es, BX
        mov bx, FAT_SECTOR_BUFFER_POINTER

        cmp ax, word[PREVIOUS_FAT_SECTOR]
        je .skip

        call READ_LBA
        mov word[PREVIOUS_FAT_SECTOR], ax

    .skip:

        add dx, bx
        mov si, dx
        mov ax, word[es:si]

    .after_next_clus:
        pop bx
        pop es

        cmp ax, 0xFFF8
        jae .done

        mov word[FILE_CLUSTER], ax
        jmp .loop

    .done:
        pop es
        popa
        ret

%endif

%ifdef FAT12

    LOAD_DIR_ENTRY: ; FILE_CLUSTER - first clustetr of a directory entry, DX:BX - load adress
        pusha
        push es
        mov es, dx

    .loop:
        xor ch, ch
        mov cl, byte[BPB_SecPerClus]
        mov ax, word[FILE_CLUSTER]
        sub ax, 2
        mul cx
        add ax, [DATA_START_SEC]

        call READ_LBA

        mov ax, word[BPB_BytesPerSec]
        xor dh, dh
        mov dl, byte[BPB_SecPerClus]
        mul dx
        add bx, ax

    .read_fat:
        push es
        push bx

        mov ax, word[FILE_CLUSTER]
        mov dx, ax
        shr ax, 1
        add ax, dx
        xor dx, dx
        div word[BPB_BytesPerSec]
        add ax, word[BPB_RsvdSecCnt]
        mov cx, 1

        mov bx, BOOTLOADER_SEG
        mov es, BX
        mov bx, FAT_SECTOR_BUFFER_POINTER

        cmp ax, word[PREVIOUS_FAT_SECTOR]
        je .skip

        call READ_LBA
        mov word[PREVIOUS_FAT_SECTOR], ax

    .skip:
        add dx, bx
        mov si, dx
        mov ax, word[es:si]

        test word[FILE_CLUSTER], 1
        jz .even

    .odd:
        shr ax, 4
        jmp .after_next_clus

    .even:
        and ax, 0xfff

    .after_next_clus:
        pop bx
        pop es

        cmp ax, 0xff8
        jae .done

        mov word[FILE_CLUSTER], ax
        jmp .loop

    .done:
        pop es
        popa
        ret
%endif

    READ_LBA:
        pusha
        push cx ;CX - amount of sectors to read
        push bx ;BX - buffer
        push ax ;AX - LBA 

        mov ax, word[BPB_Heads]
        mul word[BPB_SecPerTrack]
        mov bx, ax
        pop ax
        xor dx, dx
        div bx ;At this moment AX is Cylinder DX is temp

        push ax

        mov ax, dx
        xor dx, dx
        div word[BPB_SecPerTrack]
        inc dx ;At this moment AX is head DX is sector

        mov cx, dx ; CL - sector
        xor dx, dx
        mov dh, al ; DH - head

        pop bx  
        mov ch, bl ; CH - cylinder

        pop bx
        pop ax
        mov ah, 0x02
        mov dl, [EBR_BootDrvNumber]
        
        int 13h
        jc CRIT_ERROR

    .done:
        popa
        ret

    CRIT_ERROR:
        cli
        hlt

%ifndef FAT32
FILE_CLUSTER                dd 0
%else
FILE_CLUSTER                dw 0
%endif

DATA_START_SEC              dw 0
PREVIOUS_FAT_SECTOR         dw 0

BOOT_DIR                    db "BOOT       "
STAGE2_FILE                 db "LOADER  BIN"

BOOTLOADER_SEG              equ 0x0000

FAT_SECTOR_BUFFER_POINTER   equ BUFFER
BUFFER_POINTER              equ BUFFER + 512

STAGE2_SEG                  equ 0x0800
STAGE2_OFF                  equ 0

times 510-($-$$) db 0
dw 0xaa55

BUFFER:

;
;
;      _____            __    ____  ____
;     / __(_)_ _  ___  / /__ / __ \/ __/
;    _\ \/ /  ' \/ _ \/ / -_) /_/ /\ \  
;   /___/_/_/_/_/ .__/_/\__/\____/___/  
;              /_/                      
;
;
;